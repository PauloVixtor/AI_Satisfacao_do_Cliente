# -*- coding: utf-8 -*-
"""Satisfação_dos_passageiros.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DIv9A0w-8CLPbb5GipGYM7gOjXVogYgu
"""

# Para manipulacao dos dados
import pandas as pd
import numpy as np

# para graficos
import seaborn as sns
import matplotlib.pyplot as plt
# !pip install sweetviz
import sweetviz as sv 

# para modelagem
from sklearn.model_selection import train_test_split, GridSearchCV, ParameterGrid, KFold
from sklearn.metrics import roc_auc_score
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder


#### Settings ####
pd.set_option("max_colwidth", 1000)
pd.set_option("max_rows", 20)
pd.set_option("max_columns", 1000)
pd.set_option("precision", 2)
pd.options.display.float_format = "{:,.2f}".format
plt.style.use("classic")
# %load_ext nb_black

df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/train.csv')
df.head()

base = df.rename(columns={'Gender': 'Gênero', 'Customer Type':'Tipo_de_cliente', 'Age':'Idade', 'Type of Travel':'Tipo_de_classe_de_viagem', 
                          'Class':'Classe', 'Flight Distance':'Distância_de_Voo', 'Inflight wifi service':'Serviço_wi-fi_a_bordo', 
                          'Departure/Arrival time convenient':'Hora_de_partida|chegada_conveniente', 'Ease of Online booking':'Facilidade_de_reserva_online',
                          'Gate location':'Localização_do_portão', 'Food and drink':'Comida_e_bebida', 'Online_boarding':'Embarque_online',
                          'Seat comfort':'Conforto_do_assento', 'Inflight entertainment':'Entretenimento_em_voô', 'Serviço_de_bordo':'Serviço_de_bordo',
                          'Leg room service':'Serviço_de_quarto_para_pernas', 'Baggage_handling':'Manuseio_de_bagagem', 'Checkin service':'Serviço_de_check-in',
                          'Inflight service':'Serviço_em_voo', 'Cleanliness':'Limpeza','Departure Delay in Minutes':'Atraso_de_Partida_em_Minutos',
                          'Arrival Delay in Minutes':'Atraso_na_chegada_em_minutos', 'satisfaction':'satisfação'
                          })
base.head()

base.shape

base.describe()

base.isna().sum()

print('Porcentagem de Homens e mulheres que responderam a pesquisa!\n')
base.Gênero.value_counts(normalize=True).sort_index() * 100

#base.Gênero.value_counts()

print('Porcentagem de clientes fieis e clientes infieis\n')
base.Tipo_de_cliente.value_counts(normalize=True).sort_index() * 100

# base.Tipo_de_cliente.value_counts()

crianca = len(base.query('Idade > 10 < 20'))
jovem = len(base.query('Idade > 20 < 40'))
idoso = len(base.query('Idade > 60 < 100'))

print(f' A quantidade de criancas de 10 à 20 anos foram: {crianca}!\n',
f'A quantidade de jovens de 20 à 40 anos foram: {jovem}!\n',
f'A quantidade de jovens de 60 à 80 anos foram: {idoso}!')

# Método para tentar inferir se a variavel é categorica

provavel_categorica = {}

for var in base.columns:
  provavel_categorica[var] = 1.0 * base[var].nunique()/base[var].count() < 0.03
provavel_categorica # mostra o que é categorico.

# Porcentagem de clientes satisfeitos e insatisfeitos
base.satisfação.value_counts(normalize=True) * 100

# Inserindo condições de 0 e 1
# base['Cliente_fiel'] = np.where(base['Tipo_de_cliente'] == "Loyal Customer", 1, 0) # Cria coluna de 0 e 1
# base['Sexo'] = np.where(base['Gênero'] == "Male", 1, 0) # Cria coluna de 0 e 1
base['Resultado'] = np.where(base['satisfação'] == "neutral or dissatisfied", 0, 1) # Cria coluna de 0 e 1

base.head(10)

base.Classe.value_counts(normalize=True) * 100

# base['Nota_voo'] = nova_lista
# base.head(10)

"""## 4. MODELAGEM DE MACHINE LEARNING: RANDOM FOREST,"""

base['Resultado'] = np.where(base['satisfação'] == "satisfied", 1, 0) # Cria coluna de 0 e 1

base.columns

base.head()

# lISTANDO AS COLUNA DE DADOS QUE IREMOS SUAR

features = ['Gênero', 'Tipo_de_cliente','Tipo_de_classe_de_viagem', 'Classe',
       'Serviço_wi-fi_a_bordo', 'Hora_de_partida|chegada_conveniente',
       'Facilidade_de_reserva_online', 'Localização_do_portão',
       'Comida_e_bebida', 'Online boarding', 'Conforto_do_assento',
       'Entretenimento_em_voô', 'On-board service',
       'Serviço_de_quarto_para_pernas', 'Baggage handling',
       'Serviço_de_check-in', 'Serviço_em_voo', 'Limpeza']

target = 'Resultado'

# Divisão mde dados para treinamento

from sklearn.model_selection import train_test_split # separar por treino e teste

X = base[features] # colunas de treino
y = base[target] # Colunas de teste

# função de treino e teste

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.30, random_state = 999
)
# teste_size = 25%(Será separado em uma porcentagem, nesse caso) // Random entre 999

# Tratando as variaveis categoricas (cuidado quando for numerica)

cat_features = ['Gênero', 'Tipo_de_cliente','Tipo_de_classe_de_viagem', 'Classe'] # Categorica
num_features = ['Serviço_wi-fi_a_bordo', 'Hora_de_partida|chegada_conveniente',
       'Facilidade_de_reserva_online', 'Localização_do_portão',
       'Comida_e_bebida', 'Online boarding', 'Conforto_do_assento',
       'Entretenimento_em_voô', 'On-board service',
       'Serviço_de_quarto_para_pernas', 'Baggage handling',
       'Serviço_de_check-in', 'Serviço_em_voo', 'Limpeza'] # nuemricas

# Instalar o pacote de transformação de categoria em binario

!pip install category_encoders
import category_encoders as ce # Transforma colunas categoricas em binarias

encoder = ce.OneHotEncoder(cols=cat_features) # Como transformar

X_train = encoder.fit_transform(X_train) 
# Fazendo tratamento para treinar a rede neural

X_train.head() # Ver base do treino

# aplicando trataemntopara teste na rede neural e como ver

X_test = encoder.transform(X_test)

X_test.head() # Visualizar

# Treinando

clf_RF = RandomForestClassifier() # Cria o objeto
clf_RF.fit(X_train, y_train) # Aplica o treino nas variaveis

# Aplciar o teste

y_pred = clf_RF.predict(X_test) # Executando o teste

y_pred # Mostrar resultado do teste

# Porcentagem de acertos no codigo

from sklearn.metrics import accuracy_score

print("Acurácia: {:.2f}%".format(accuracy_score(y_test, y_pred) * 100))  # quantidade de acertos do codigo

from sklearn.metrics import f1_score

print(
    "F1 Score: {:.2f}%".format(f1_score(y_test, y_pred) * 100)
)  # indica poucos falsos positivos e falsos negativos, quanto mais próximo de 1, melhor

from sklearn.metrics import confusion_matrix

tn, fp, fn, tp = confusion_matrix(y_test, y_pred).ravel()

print("True Positive: " + str(tp)) # Verdadeiro positivo
print("True Negative: " + str(tn)) # Verdadeiro Negativo
print("False Positive: " + str(fp)) # Falso positivo
print("False Negative: " + str(fn)) # Falso Negativo

from sklearn.metrics import classification_report

print(classification_report(y_test, y_pred))

#  Importancia das colunas
feature_imp = pd.Series(clf_RF.feature_importances_, index=X_train.columns).sort_values(
    ascending=False
)
feature_imp

# Creating a bar plot // Visualizar a imporancia de cada coluna dentro da rede neural.
_ = plt.figure(figsize=(10, 6))
_ = sns.barplot(x=feature_imp, y=feature_imp.index)

# Add labels to your graph
_ = plt.xlabel("Feature Importance Score")
_ = plt.ylabel("Features")
_ = plt.title("Visualização da Importantancia de cada coluna")
_ = plt.savefig("rf_features.png")

# CURVA ROC: calcula fpr e tpr para vários limiares, Verificar a quantidade ce acertos e erros.
from sklearn.metrics import roc_curve
from sklearn.model_selection import cross_val_predict

# probabilidades
# probs = clf_RF.predict_proba(X_test)

y_scores = cross_val_predict(clf_RF, X_test, y_test)

# obtem fpr, tpr e limites
fpr, tpr, thresholds = roc_curve(y_test, y_scores)


def plot_roc_curve(fpr, tpr, label=None):
    plt.plot(fpr, tpr, linewidth=2, label=label)
    plt.plot([0, 1], [0, 1], "k--")
    plt.axis([0, 1, 0, 1])
    plt.xlabel("False Positive Rate")
    plt.ylabel("True Positive Rate")


plot_roc_curve(fpr, tpr)

"""# **Visualização em grafico**"""

pallete = sns.color_palette('Blues', 5) # Cria Pallete  de cores
pallete = sns.cubehelix_palette(7, start=2, rot=0, dark=0, light=.5)
# _ = sns.countplot(base['Hora_de_partida|chegada_conveniente'], palette=pallete) # aplica no grafico
_ = sns.countplot(data = base, x='Hora_de_partida|chegada_conveniente', palette=pallete)
_ = plt.title('Satisfação de chegada e saída do voo')
_ = plt.show()

plt.figure(figsize=(5,5))
plt.pie(x=base['Classe'].value_counts(),labels= base['Classe'].value_counts().index, autopct='%0.2f%%')
plt.title("Classe dentro do voo")
plt.show()

palt = sns.color_palette('BrBG', 5) # Cria Pallete  de cores
palt = sns.cubehelix_palette(7, start=2, rot=0, dark=0, light=.95)
Gener = sns.barplot(data = base, x='Online boarding', y ='Classe', palette=palt)
plt.title("Embarque online por Classe")
plt.show()

plt.figure(figsize=(5,5))
plt.pie(x=base['Gênero'].value_counts(),labels= base['Gênero'].value_counts().index, autopct='%0.2f%%')
plt.title("Porcentagem por Gênero")
plt.show()

"""# **ML de Classificação**"""

from sklearn.neural_network import MLPClassifier

clf_CLA = MLPClassifier(hidden_layer_sizes=(10,), learning_rate='constant',
                    learning_rate_init=0.001, max_iter=3000)
clf_CLA.fit(X_train, y_train)

x_pred = clf_CLA.predict(X_test) # Executando o teste

x_pred # Mostrar resultado do teste

# Porcentagem de acertos no codigo

from sklearn.metrics import accuracy_score

print("Acurácia: {:.2f}%".format(accuracy_score(y_test, x_pred) * 100))  # quantidade de acertos do codigo

from sklearn.metrics import f1_score

print(
    "F1 Score: {:.2f}%".format(f1_score(y_test, x_pred) * 100)
)  # indica poucos falsos positivos e falsos negativos, quanto mais próximo de 1, melhor

from sklearn.metrics import roc_curve
from sklearn.model_selection import cross_val_predict

# probabilidades
# probs = clf_RF.predict_proba(X_test)

y_scores = cross_val_predict(clf_CLA, X_test, y_test)

# obtem fpr, tpr e limites
fpr, tpr, thresholds = roc_curve(y_test, y_scores)


def plot_roc_curve(fpr, tpr, label=None):
    plt.plot(fpr, tpr, linewidth=2, label=label)
    plt.plot([0, 1], [0, 1], "k--")
    plt.axis([0, 1, 0, 1])
    plt.xlabel("False Positive Rate")
    plt.ylabel("True Positive Rate")

plot_roc_curve(fpr, tpr)

"""# **ML de Regressão**"""

from sklearn.neural_network import MLPRegressor

clf_GRE = MLPRegressor(hidden_layer_sizes=(10,), learning_rate='constant',
                    learning_rate_init=0.001, max_iter=3000)
clf_GRE.fit(X_train, y_train)

z_pred = clf_GRE.predict(X_test) # Executando o teste

z_pred # Mostrar resultado do teste

acuracia_trein = clf_GRE.score(X_test, y_test)
print("Acurácia do Treinamento = %.2f%%" %(acuracia_trein*100.0))

"""**DASHBOARD AUTOMATIZADO**

"""

# Dashboard com duas linhas / Usando SWEETVIZ

reporte = sv.analyze(base) # Fazer analise do grafico
reporte.show_html()

# Para abrir o arquivo SWEETVIZ_REPORT procure nos arquivo a direita.
# Se clicar em um grafico ele trava